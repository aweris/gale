package ghx

import (
	"context"
	"fmt"

	"github.com/aweris/gale/internal/core"
	"github.com/aweris/gale/internal/expression"
	"github.com/aweris/gale/internal/gctx"
	"github.com/aweris/gale/internal/idgen"
	"github.com/aweris/gale/internal/log"
)

var _ TaskResult = new(JobResult)

// JobResult represents the result of a job
type JobResult struct {
	RunID      string            `json:"run_id"`     // RunID is the run id of the job run
	Conclusion core.Conclusion   `json:"conclusion"` // Conclusion is the result of a completed step after continue-on-error is applied
	Outcome    core.Conclusion   `json:"outcome"`    // Outcome is  the result of a completed step before continue-on-error is applied
	Outputs    map[string]string `json:"outputs"`    // Outputs is the outputs generated by the job
}

// GetConclusion returns the conclusion of the task.
func (r JobResult) GetConclusion() core.Conclusion {
	return r.Conclusion
}

// JobRunner is the runner that executes the job.
type JobRunner struct {
	RunID    string                  // RunID is the run id of the job run.
	Job      core.Job                // Job is the job to be executed.
	context  *ExprContext            // context is the expression context for the job run.
	executor TaskExecutor[JobResult] // executor is the main task executor that executes the job and keeps the execution information.
}

// planJob plans the job and returns the job runner.
func planJob(rc *gctx.Context, job core.Job) (*JobRunner, error) {
	runID, err := idgen.GenerateJobRunID()
	if err != nil {
		return nil, err
	}

	runner := &JobRunner{
		RunID: runID,
		Job:   job,
	}

	// initialize the expression context
	ec, err := NewExprContext(rc.Secret)
	if err != nil {
		return nil, err
	}

	runner.context = ec

	// step task executors that execute the steps
	var (
		setupFns = make([]TaskExecutorFn[StepResult], 0)
		pre      = make([]TaskExecutor[StepResult], 0)
		main     = make([]TaskExecutor[StepResult], 0)
		post     = make([]TaskExecutor[StepResult], 0)
	)

	for idx, step := range job.Steps {
		if step.ID == "" {
			step.ID = fmt.Sprintf("%d", idx)
		}

		sr, err := NewStep(runner, step)
		if err != nil {
			return nil, err
		}

		// if step implements setup hook, add the setup function to the setupFns slice to be executed
		// by the setup task executor.
		if setup, ok := sr.(SetupHook); ok {
			setupFns = append(setupFns, setup.setup())
		}

		// if step implements pre hook, add the pre task executor to the tasks slice.
		if hook, ok := sr.(PreHook); ok {
			// pre task is added same index as the step index
			pre = append(pre, NewConditionalTaskExecutor(getStepName("Pre", step), hook.pre(), hook.preCondition()))
		}

		// main tasks starts after pre tasks. so index is step index + len(steps)
		prefix := ""
		if step.Name == "" {
			prefix = "Run"
		}
		main = append(main, NewConditionalTaskExecutor(getStepName(prefix, step), sr.main(), sr.condition()))

		if hook, ok := sr.(PostHook); ok {
			post = append(post, NewConditionalTaskExecutor(getStepName("Post", step), hook.post(), hook.postCondition()))
		}
	}

	var tasks = make([]TaskExecutor[StepResult], 0)

	tasks = append(tasks, NewTaskExecutor("Set up job", setup(runner, setup(runner, setupFns...))))
	tasks = append(tasks, pre...)
	tasks = append(tasks, main...)
	tasks = append(tasks, post...)
	tasks = append(tasks, NewTaskExecutor("Complete job", complete(runner)))

	// main task executor that executes the job
	runner.executor = NewTaskExecutor[JobResult](fmt.Sprintf("Job: %s", job.Name), func(ctx context.Context) (*JobResult, error) {
		for _, te := range tasks {
			run, result, err := te.Run(ctx)

			// no need to continue if the task executor did not run.
			if !run {
				continue
			}

			if err != nil {
				log.Errorf(te.Name, "error", err.Error())
			}

			// set the job status to the conclusion of the job status is success and the conclusion is not success.
			if ec.Job.Status == core.ConclusionSuccess && result.Conclusion != ec.Job.Status {
				ec.SetJobStatus(result.Conclusion)
			}
		}

		totalSize := 0
		outputs := make(map[string]string, len(runner.Job.Outputs))

		for k, v := range runner.Job.Outputs {
			val, err := expression.NewString(v).Eval(runner.context)
			if err != nil {
				res := &JobResult{
					RunID:      runID,
					Conclusion: core.ConclusionFailure,
					Outcome:    core.ConclusionFailure,
					Outputs:    outputs,
				}

				return res, err
			}

			log.Debugf("Evaluated output", "key", k, "value", val)

			// According to Github Action docs, Outputs are Unicode strings, and can be a maximum of 1 MB in size.
			// We'll check the size of the output and log a warning if it's bigger than 1MB.
			//
			// See: https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idoutputs
			if len(val) > 1*MB {
				log.Warnf("Size of the output is bigger than 1MB", "key", k, "size", fmt.Sprintf("%dMB", len(val)/MB))
			}

			totalSize += len(val)

			outputs[k] = val
		}

		// According to Github Action docs, The total of all outputs in a workflow run can be a maximum of 50 MB.
		// We'll check the size of the outputs and log a warning if it's bigger than 50MB.
		//
		// See: https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idoutputs
		if totalSize > 50*MB {
			log.Warnf("Total size of the outputs is bigger than 50MB", "size", fmt.Sprintf("%dMB", totalSize/MB))
		}

		result := &JobResult{
			Conclusion: ec.Job.Status,
			Outcome:    ec.Job.Status,
			Outputs:    outputs,
		}

		return result, nil
	})

	return runner, nil
}

// Run runs the job and updates job results.
func (r *JobRunner) Run(ctx context.Context) (bool, *JobResult, error) {
	return r.executor.Run(ctx)
}

// setup returns a task executor function that will be executed by the task executor for the setup step.
func setup(_ *JobRunner, setupFns ...TaskExecutorFn[StepResult]) TaskExecutorFn[StepResult] {
	return func(ctx context.Context) (*StepResult, error) {
		for _, setupFn := range setupFns {
			result, err := setupFn(ctx)
			if err != nil {
				return result, err
			}
		}

		return SuccessStepResult("setup"), nil
	}
}

// MB is the megabyte size in bytes. It'll be used to check size of the job outputs. This just to increase the
// readability of the code.
const MB = 1024 * 1024

// complete returns a task executor function that will be executed by the task executor for the complete step.
func complete(r *JobRunner) TaskExecutorFn[StepResult] {
	return func(ctx context.Context) (*StepResult, error) {
		log.Infof("Complete", "job", r.Job.Name, "conclusion", r.context.Job.Status)

		return SuccessStepResult("complete"), nil
	}
}
