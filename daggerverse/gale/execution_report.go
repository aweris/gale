package main

import (
	"context"
	"encoding/json"

	"github.com/aweris/gale/common/model"
	ghxcontext "github.com/aweris/gale/ghx/context"
)

// FIXME: Report structs are modified copies of the structs in ghx/context/reports.go to workaround the dagger's
//  not supporting map types. Once dagger supports map types, these structs should be moved to common package and
//  used in both ghx and gale.

// TODO: Removed 'Matrix     model.MatrixCombination` from report since it's not possible use map and don't know
//  how to handle interface{} in dagger. Find way to handle this.

type JobRunReport struct {
	Ran        bool             // Ran indicates if the execution ran
	Duration   string           // Duration of the execution
	Name       string           // Name is the name of the job
	RunID      string           // RunID is the ID of the run
	Conclusion model.Conclusion // Conclusion is the result of a completed job after continue-on-error is applied
	Outcome    model.Conclusion // Outcome is  the result of a completed job before continue-on-error is applied
	Outputs    []KV             // Outputs is the outputs generated by the job
	Steps      []StepRunSummary // Steps is the list of steps in the job
	File       *File            // File is the report file contains original json report of the job
}

type StepRunSummary struct {
	StepID     string           // ID is the unique identifier of the step.
	Name       string           // Name is the name of the step
	Stage      model.StepStage  // Stage is the stage of the step during the execution of the job. Possible values are: setup, pre, main, post, complete.
	Conclusion model.Conclusion // Conclusion is the result of a completed job after continue-on-error is applied
}

func toJobRunReport(ctx context.Context, file *File) (*JobRunReport, error) {
	reportVal, err := file.Contents(ctx)
	if err != nil {
		return nil, err
	}

	// original report model to unmarshal the report file
	var reportModel ghxcontext.JobRunReport

	if err := json.Unmarshal([]byte(reportVal), &reportModel); err != nil {
		return nil, err
	}

	var steps []StepRunSummary

	for _, step := range reportModel.Steps {
		steps = append(steps, StepRunSummary{
			StepID:     step.ID,
			Name:       step.Name,
			Stage:      step.Stage,
			Conclusion: step.Conclusion,
		})
	}

	report := &JobRunReport{
		Ran:        reportModel.Ran,
		Duration:   reportModel.Duration,
		Name:       reportModel.Name,
		RunID:      reportModel.RunID,
		Conclusion: reportModel.Conclusion,
		Outcome:    reportModel.Outcome,
		Outputs:    mapToKV(reportModel.Outputs),
		Steps:      steps,
		File:       file,
	}

	return report, nil
}
