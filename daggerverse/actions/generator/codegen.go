package main

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/dave/jennifer/jen"

	"github.com/aweris/gale/common/model"
)

var (
	DefaultRuntimeParams = []jen.Code{
		jen.Line().Comment("Directory containing the repository source. Takes precedence over `--repo`.").Line().Id("source").Id("Optional[*Directory]"),
		jen.Line().Comment("Repository name, format: owner/name. Takes precedence over `--source`.").Line().Id("repo").Id("Optional[string]"),
		jen.Line().Comment("Tag name to check out. Only works with `--repo`. Takes precedence over `--branch`.").Line().Id("tag").Id("Optional[string]"),
		jen.Line().Comment("Branch name to check out. Only works with `--repo`.").Line().Id("branch").Id("Optional[string]"),
		jen.Line().Comment("Image for the runner.").Line().Id("runnerImage").Id("Optional[string]"),
		jen.Line().Comment("Enables debug mode.").Line().Id("runnerDebug").Id("Optional[bool]"),
		jen.Line().Comment("GitHub token. May be required for certain actions.").Line().Id("token").Id("Optional[*Secret]"),
	}
	DefaultRuntimeRunOpts = jen.Id("ActionsRuntimeRunOpts").
				Values(
			jen.Dict{
				jen.Id("Source"):      jen.Id("source.GetOr(nil)"),
				jen.Id("Repo"):        jen.Id("repo.GetOr(\"\")"),
				jen.Id("Tag"):         jen.Id("tag.GetOr(\"\")"),
				jen.Id("Branch"):      jen.Id("branch.GetOr(\"\")"),
				jen.Id("RunnerImage"): jen.Id("runnerImage.GetOr(\"\")"),
				jen.Id("RunnerDebug"): jen.Id("runnerDebug.GetOr(false)"),
				jen.Id("Token"):       jen.Id("token.GetOr(nil)"),
			},
		)
)

// generateModuleCode generates the module code for the given custom action.
func generateModuleCode(ca *action) (*File, error) {
	// create the Jennifer file containing the code for the custom action
	file := createJenFile(ca)

	// create the dagger file from the Jennifer file
	return createDaggerFileFromJen(file)
}

// createDaggerFileFromJen saves the Jennifer file to disk and returns the corresponding *File
func createDaggerFileFromJen(f *jen.File) (*File, error) {
	// create a temporary file path
	tempPath := filepath.Join(os.TempDir(), "main.go")

	// save the Jennifer file to disk
	if err := f.Save(tempPath); err != nil {
		return nil, err
	}

	// return the dagger file from the temporary file path
	return dag.Host().File(tempPath), nil
}

// createJenFile creates a Jennifer file for the given custom action.
func createJenFile(ca *action) *jen.File {
	module := formatModuleName(ca.RepoName)
	f := jen.NewFile("main")

	// header comment
	f.HeaderComment("Code generated by actions-generator. DO NOT EDIT.")

	// entrypoint
	f.Comment(fmt.Sprintf("Dagger module for executing the %s GitHub Action.", ca.Repo)).Line().
		Add(jen.Type().Id(module).Struct())

	// run function
	f.Comment(fmt.Sprintf("Runs the %s GitHub Action.", ca.Repo)).Line().
		Add(generateRunFnSignature(module, ca.Meta.Inputs)).
		Add(generateRunFnBody(ca))

	return f
}

// generateRunFnSignature generates the run function signature for the given custom action.
func generateRunFnSignature(module string, caInputs map[string]model.CustomActionInput) *jen.Statement {
	return jen.Func().
		Params(jen.Id("m").Id(module)).Id("Run").Params(generateParams(caInputs)...).Id("*Container")
}

// generateRunFnBody generates the run function body for the given custom action.
func generateRunFnBody(ca *action) *jen.Statement {
	return jen.Block(
		jen.Comment("initializing runtime options").Line().Id("opts").Op(":=").Add(DefaultRuntimeRunOpts),
		jen.Line(),
		jen.Return(getActionRuntimeSync(ca)),
	)
}

// generateParams generates the parameters for the run function.
func generateParams(caInputs map[string]model.CustomActionInput) []jen.Code {
	params := make([]jen.Code, 0, len(caInputs)+len(DefaultRuntimeParams)+1) // +1 for newline after last param

	// use sorted keys to ensure consistent output
	for _, inputName := range getSortedKeys(caInputs) {
		input := caInputs[inputName]
		param := jen.Line().Comment(input.Description).Line().Id(formatActionInputName(inputName))
		if !input.Required || input.Default != "" {
			param.Id("Optional[string]")
		} else {
			param.Id("string")
		}
		params = append(params, param)
	}

	params = append(params, DefaultRuntimeParams...)
	params = append(params, jen.Line())

	return params
}

// generateInputs generates the WithInput calls for the action/runtime module call.
func generateInputs(caInputs map[string]model.CustomActionInput) []jen.Code {
	inputs := make([]jen.Code, 0, len(caInputs))

	// use sorted keys to ensure consistent output
	for _, inputName := range getSortedKeys(caInputs) {
		input := caInputs[inputName]
		callType := jen.Id(formatActionInputName(inputName))
		if !input.Required || input.Default != "" {
			callType = callType.Dot("GetOr").Call(jen.Lit(input.Default))
		}
		inputs = append(inputs, jen.Dot(startWithNewLine("WithInput")).Call(jen.Lit(inputName), callType))
	}

	return inputs
}

// getActionRuntimeSync returns the action runtime execution code.
func getActionRuntimeSync(ca *action) *jen.Statement {
	return jen.Id("dag").Dot("ActionsRuntime").Call().Dot(startWithNewLine("Run")).
		Call(jen.Lit(fmt.Sprintf("%s@%s", ca.Repo, ca.Ref)), jen.Id("opts")).
		Add(generateInputs(ca.Meta.Inputs)...).
		Dot(startWithNewLine("Sync")).
		Call()
}
